# Основные паттерны микросервисной архитектуры

## 1. APIGateway
Единая точка входа для всех клиентских запросов, которая маршрутизирует их к соответствующим микросервисам. Также может выполнять функции аутентификации, логирования, ограничения скорости и трансформации запросов/ответов.
**Когда использовать:** Когда нужно унифицировать доступ к микросервисам и скрыть их сложность от клиента.
**Решает:**
{% cut "Проблема разрастания эндпоинтов и как API Gateway её решает" %}

- Если клиенту надо получить данные от нескольких сервисов то он будет зависеть от одной точки входа
- Клиенты меньше зависят от внутренней структуры
- Его легче масштабировать нежели сервисы

{% endcut %}
{% cut "Обработка cross-cutting concerns" %}

API Gateway является единой точкой входа, а значит можно централизовано выполнять сквозные операции:
- Авторизация
- Логирование
- Rate Limiting
- Кеширование
- Мониторинг
- т.д.

{% endcut %}

Примеры:
- KRakend (внешний сервис)
- Envoy (внешний сервис)
- Ocelot (.NET библиотека)

## 2. Service Discovery
Механизм, позволяющий микросервисам находить друг друга в динамической среде (например, при масштабировании).
**Когда использовать:** Когда микросервисы часто добавляются/удаляются (например, в Kubernetes).
**Решает:**
{% cut "Проблема обнаружения сервисов" %}

Если у нас развернуто много экземпляров одного и того же сервиса нужно понимать к какому модно обращаться, клиент сам может хранить или запрашивать у кого-то список доступных адресов но это лишнее услоднение клиента, мы можем вынести уэту логику на еще один слойm тем самым централизовав вход и упростив логиу для клиента

{% endcut %}

Примеры:
- Eureka (внешний сервис)
- Consul (внешний сервис)

## 3. Circuit Breaker
Защищает систему от каскадных сбоев, отключая запросы к сервису, который не отвечает, и позволяя ему восстановиться.
**Когда использовать:** Для повышения отказоустойчивости при взаимодействии с ненадежными сервисами.
**Решает:**
{% cut "Проблема каскадных сбоев" %}

Circuit Breaker изолирует сбой в рамках одного сервиса и не дает другим сервисам исчерпать ресурсы на бесконечные попытки обращения к сбоящему сервису.
Может быть реализован как отдельынй сервис или часть кода.

{% endcut %}

## 4. Database per Service
Каждый микросервис имеет собственную базу данных, чтобы обеспечить независимость и слабую связанность.
**Когда использовать:** Когда требуется изолировать данные микросервисов.
**Решает:**
{% cut "Проблема одной БД" %}

- Упрошает масштабируемость
- Ограничивает сервисы только их данными
- Позвоялет избежать наличия единйо точки отказа
- Тесная связность

{% endcut %}

## 5. Event-Driven Architecture (Event Sourcing / CQRS)
Микросервисы обмениваются данными через события (например, через Kafka или RabbitMQ). CQRS разделяет операции чтения и записи.
**Когда использовать:** Для асинхронной коммуникации и высокой масштабируемости.

{% note info %}

MassTransit - библиотека для работы с брокерами сообщений

{% endnote %}

## 6. Saga
Координация распределенных транзакций через серию локальных транзакций, управляемых событиями (Choreography) или централизованным оркестратором (Orchestration).
**Когда использовать:** Для управления сложными бизнес-процессами, охватывающими несколько сервисов.
{% cut "Хореография" %}

Это децентрализованный подход, при котором микросервисы взаимодействуют через события, самостоятельно определяя, как реагировать на них. Каждый сервис подписывается на интересующие его события и выполняет свои действия, не завися от центрального координатора.

{% note tip %}

- Гибкость
- Масштабируемость
- Децинтрализованность

{% endnote %}

{% note alert %}

- Сложность дебага
- Консистентность данных

{% endnote %}

{% endcut %}

{% cut "Оркестрация" %}

это централизованный подход, при котором один сервис (оркестратор) управляет всем бизнес-процессом, вызывая другие сервисы через команды или API и координируя их действия.

{% note tip %}

- Прозрачность
- Единый контроль
- Легкое тестирование

{% endnote %}

{% note alert %}

- Единая точка отказа
- Высокая связность
- Сложное масштабирование

{% endnote %}

{% endcut %}

## 7. Sidecar
Размещение вспомогательной функциональности (логирование, мониторинг, прокси) в отдельном процессе или контейнере, работающем рядом с микросервисом.
**Когда использовать:** Для добавления кросс-каттинговых функций без изменения кода сервиса.

{% note info %}

Это отдельный процесс или контейнер, который работает в паре с основным сервисом и взаимодействует с ним через локальную сеть (например, localhost) или общие ресурсы (например, файловую систему).

{% endnote %}

**Пример:**
- Основной сервис — это веб-приложение, обрабатывающее HTTP-запросы.
- Сайдкар — это контейнер с прокси (например, Envoy), который обрабатывает входящий и исходящий трафик, обеспечивая балансировку нагрузки, шифрование или аутентификацию.

## 8. Bulkhead
Изоляция ресурсов (потоки, соединения) для предотвращения влияния сбоя одного сервиса на другие.
**Когда использовать:** Для повышения отказоустойчивости.

## 9. BFF
Создание отдельных бэкендов для каждого типа клиента (мобильный, веб), чтобы оптимизировать API под их нужды.
**Когда использовать:** Когда разные клиенты требуют разные данные или форматы.

## 10. Strangler
Постепенная замена монолитного приложения микросервисами путем перенаправления запросов к новым сервисам.
**Когда использовать:** При рефакторинге legacy-систем.