# SOLID

## 1. Single Responsibility Principle
Класс должен иметь только одну причину для изменения. Если класс имеет более однйо причины для изменения (зоны ответственности), то его становится тяжелее тестировать и поддерживать. Разделение ответственности улучшает читаемость и переиспользуемость кода.

**Паттерны решающие проблему**:
- Facade
- Startegy
- Command
- Repository
- Service Layer

## 2. Open/Closed principle
Классы должны быть открыты для расширения, но закрыты для модификации. Новое поведение добавляется через наследование или композицию, а не изменение существующего кода. Позволяет добавлять новый функционал без рик сломать существующий код.

**Паттерны решающие проблему**:
- Strategy
- Factory Method
- Abstract Factory
- Decorator
- Template Method
- Visitor
- Adapter
- Bridge

## 3. Liskov Substitution Principle
Объекты базового класса должны быть заменяемы объектами производных классов без изменения работы программы. Производные класс должны вести сеф так же как базовые классы.

**Паттерны решающие проблему**:
- Strategy
- Factory Method
- Abstract Factory
- Template Method

## 4. Interface Segregation Principle
Интерфесы не должны быть большими. Большие интерфейсы заставляют классы реализовывать ненужные методы.

**Паттерны решающие проблему**:
- Strategy
- Facade
- Adapter
- Decorator
- Composite

## 5. Dependency Inversion Principle
Модули верхнего уровня не должны зависеть от модулей нижнего уровня. Оба должны зависеть от абстракции. Абстракции не должны зависеть от деталей реализации. Снижает связность и упрощает тестирование.

**Паттерны решающие проблему**:
- Dependecy Injection
- Service Locator
- Factory Method
- Abstract Factory
- Strategy
- Bridge
- Adapter