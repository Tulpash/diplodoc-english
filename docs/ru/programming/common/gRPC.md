# gRPC
**gRPC** — это высокопроизводительный фреймворк для удаленного вызова процедур (Remote Procedure Call, RPC), разработанный Google. Он широко используется для построения масштабируемых и быстрых распределенных систем, особенно в микросервисной архитектуре. gRPC основан на HTTP/2 и использует Protocol Buffers (Protobuf) для сериализации данных.

## Как устроен
- Схема контракта: Определение сервиса и его методов описывается в файле .proto с использованием языка Protocol Buffers. Этот контракт задает, какие методы доступны, их входные и выходные параметры.
- Сгенерированный код: На основе .proto файла генерируется код для клиента и сервера на выбранном языке (например, C#). Это включает заглушки (stubs) для клиента и базовые классы для сервера.
- gRPC Runtime: Библиотека gRPC (например, Grpc.Core или Grpc.Net.Client в C#) управляет соединением, сериализацией/десериализацией данных и обработкой вызовов.

## Типы вызовов:
- Унарный вызов (Unary): Простой запрос-ответ, как обычная функция.
- Поток от сервера (Server Streaming): Сервер отправляет поток сообщений в ответ на один запрос.
- Поток от клиента (Client Streaming): Клиент отправляет поток сообщений, сервер отвечает одним сообщением.
- Двунаправленный поток (Bidirectional Streaming): Оба участника обмениваются потоками сообщений.

## Как gRPC использует HTTP 2
- Мультиплексирование: HTTP/2 позволяет отправлять несколько запросов и ответов одновременно по одному TCP-соединению. Это снижает задержки и устраняет проблему блокировки заголовка (head-of-line blocking).
- Сжатие заголовков: HTTP/2 использует алгоритм HPACK для сжатия заголовков, что уменьшает объем передаваемых метаданных.
- Двоичный формат: HTTP/2 использует двоичный протокол (вместо текстового, как в HTTP/1.1), что делает его более эффективным.
- Потоки (Streams): gRPC использует потоки HTTP/2 для реализации серверного, клиентского и двунаправленного потокового обмена данными.
- Долгоживущие соединения: HTTP/2 поддерживает постоянные соединения, что идеально для gRPC, где клиент и сервер могут поддерживать соединение для множества вызовов.

## Как устроен Protobuf
- Схема: Структура данных определяется в `.proto` файлах. Например:
```proto
message Person {
  int32 id = 1;
  string name = 2;
  bool is_active = 3;
}
```
Здесь id, name, is_active — поля, а числа (1, 2, 3) — это теги, которые используются для идентификации полей в бинарном формате.
- Двоичный формат: Protobuf сериализует данные в компактный двоичный формат, что быстрее и экономичнее по сравнению с JSON или XML.
- Обратная совместимость: Protobuf поддерживает добавление новых полей без нарушения совместимости со старыми клиентами/серверами (если не удалять поля и не менять их теги).
- Кроссплатформенность: Protobuf поддерживает генерацию кода для множества языков, включая C#, Go, Java, Python и др.

**Как работает сериализация:**
- Каждое поле в сообщении кодируется как пара "тег-значение".
- Тег указывает номер поля (например, 1 для id) и тип данных.
- Значение кодируется в зависимости от типа (например, int32 кодируется с использованием varint для экономии места).
- Поля, которые не заданы, не включаются в сериализованные данные, что уменьшает размер сообщения.

**Пример `.proto` файла:**
```proto
syntax = "proto3";

service Greeter {
  rpc SayHello (HelloRequest) returns (HelloReply);
}

message HelloRequest {
  string name = 1;
}

message HelloReply {
  string message = 1;
}
```

## Передача метаданных в gRPC
Метаданные (metadata) в gRPC — это дополнительная информация, передаваемая вместе с запросом или ответом, аналогично заголовкам HTTP. Они используются для передачи контекстной информации, например, токенов аутентификации, идентификаторов запросов или пользовательских параметров.

**Как устроены метаданные:**
- Метаданные представляют собой пары ключ-значение (`string-string` или `string-byte[]`).
- Они передаются в заголовках HTTP/2.
- gRPC различает заголовки (отправляются до тела запроса) и трейлеры (отправляются после тела, часто для статуса или ошибок).

**Передача метаданных:**
- На клиенте: Метаданные добавляются в объект Metadata и передаются при вызове метода.
- На сервере: Сервер может получить метаданные из контекста вызова и отправить свои метаданные в ответ.