# Тестирование

## 1. Unit Tests
Юнит-тестирование — это метод тестирования, при котором проверяется поведение отдельных "единиц" кода (обычно методов или функций) в изоляции от остальной системы. Цель — убедиться, что каждая единица работает правильно и соответствует ожидаемому поведению.
**Цель:** убедиться что каждая еденица кода работает корректно
**Ключевые принципы:**
- *Изоляция:* Тестируемая единица (например, метод) проверяется без зависимости от других компонентов. Зависимости (например, базы данных, сервисы) заменяются заглушками (mocks/stubs).
- *Автоматизация:* Тесты пишутся в виде кода и выполняются автоматически.
- *Повторяемость:* Тесты дают одинаковый результат при каждом запуске.
- *Быстрота:* Юнит-тесты должны быть быстрыми (миллисекунды на тест).
- *Читаемость:* Тесты должны быть понятными, как спецификация.

## 2. Integration Tests
Интеграционные тесты проверяют, как отдельные модули (юниты) интегрируются и взаимодействуют друг с другом. Они фокусируются на интерфейсах между компонентами, передаче данных, последовательности вызовов и интеграции с внешними зависимостями (например, базами данных, веб-сервисами, файловыми системами).
**Цели:**
- Выявить дефекты в интеграции: несоответствия интерфейсов, ошибки в сериализации/десериализации данных, проблемы с сетевыми вызовами.
- Проверить поведение системы в реальных сценариях: например, как контроллер в ASP.NET взаимодействует с репозиторием и БД.
- Обеспечить, что компоненты работают вместе, как ожидается, без неожиданных побочных эффектов.
**Уровни интеграции:**
- Big Bang: Все модули интегрируются сразу и тестируются целиком (рискованно, сложно отлаживать).
- Top-Down: Тестирование начинается с верхних уровней (UI/контроллеры), а нижние заменяются заглушками (stubs).
- Bottom-Up: Тестирование от нижних уровней (репозитории, сервисы) вверх, с использованием драйверов для симуляции верхних уровней.
- Sandwich/Hybrid: Комбинация top-down и bottom-up.

## 3. E2E
E2E (end-to-end) тестирование проверяет полный поток работы приложения от начала до конца, эмулируя действия реального пользователя. Это включает взаимодействие с UI (если есть), API, базами данных, внешними сервисами и инфраструктурой.
**Цели:**
- Убедиться, что вся система работает корректно в реальных условиях.
- Проверить пользовательские сценарии (например, регистрация, покупка в интернет-магазине).
- Выявить проблемы, которые не ловятся на уровне юнит- или интеграционных тестов (например, несоответствия в UI-backend интеграции, сетевые ошибки, конфигурационные проблемы).
**Характеристики:**
- Самые медленные и сложные в написании
- Используют инструменты, такие как Selenium, Cypress или Playwright, для имитации действий пользователя в браузере.

## 4. Нагрузочное
Нагрузочное тестирование моделирует реальную или пиковую нагрузку на систему, чтобы измерить её производительность, выявить узкие места и проверить, соответствует ли она требованиям по скорости, стабильности и масштабируемости.
**Цели:**
- Производительность: Оценить время отклика, пропускную способность (throughput) и использование ресурсов (CPU, память, I/O).
- Масштабируемость: Проверить, как система справляется с увеличением нагрузки (например, рост числа пользователей).
- Стабильность: Убедиться, что система не падает при длительной или пиковой нагрузке.
Узкие места: Найти лимиты (например, БД, сеть, ThreadPool) и проблемы (утечки памяти, блокировки).
**Типы нагрузочного тестирования:**
- Load Testing: Проверка поведения при ожидаемой нагрузке (например, 1000 пользователей).
- Stress Testing: Тестирование за пределами нормальной нагрузки, чтобы найти точку отказа.
- Soak Testing: Длительная нагрузка для проверки стабильности (например, 24 часа).
- Spike Testing: Резкое увеличение нагрузки (например, внезапный наплыв пользователей).
- Scalability Testing: Проверка масштабирования при росте ресурсов (например, добавление серверов).