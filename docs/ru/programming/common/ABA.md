# ABA
Это классическая проблема в многопоточном программировании, связанная с использованием атомарных операций, таких как Compare-and-Swap (CAS), в lock-free алгоритмах. Она возникает, когда поток делает предположение о состоянии ресурса на основе его значения, но это значение может измениться и вернуться к исходному, что приводит к некорректной логике. В контексте C#, ABA-проблема чаще всего встречается при использовании методов класса System.Threading.Interlocked, таких как Interlocked.CompareExchange.

## ABA-проблема происходит, когда:**
1. Поток A читает значение переменной (например, X = A).
1. Поток A вычисляет новое значение для обновления (например, хочет заменить A на B).
1. В это время другой поток (или потоки) изменяет значение переменной с A на что-то другое (например, B), а затем обратно на A.
1. Поток A выполняет CAS, проверяя, что текущее значение всё ещё A. Поскольку значение снова A, CAS считает, что ничего не изменилось, и успешно обновляет переменную, хотя на самом деле промежуточные изменения могли повлиять на логику программы.

**Ключевой момент:** CAS проверяет только значение переменной, но не её историю изменений. Это может привести к ошибкам, если логика программы зависит от того, что переменная оставалась неизменной с момента чтения.

## Пример ABA-проблемы
Рассмотрим lock-free стек, где элементы добавляются (Push) и удаляются (Pop) с использованием CAS. Предположим, стек реализован как односвязный список, где head указывает на верхний элемент.
```cs
class Node
{
    public int Value;
    public Node Next;
}

class LockFreeStack
{
    private Node head;

    public void Push(int value)
    {
        Node newNode = new Node { Value = value };
        Node oldHead;
        do
        {
            oldHead = head;
            newNode.Next = oldHead;
        } while (Interlocked.CompareExchange(ref head, newNode, oldHead) != oldHead);
    }

    public bool TryPop(out int value)
    {
        Node oldHead, next;
        do
        {
            oldHead = head;
            if (oldHead == null)
            {
                value = 0;
                return false; // Стек пуст
            }
            next = oldHead.Next;
        } while (Interlocked.CompareExchange(ref head, next, oldHead) != oldHead);
        value = oldHead.Value;
        return true;
    }
}
```
**Сценарий ABA-проблемы:**
1. Поток A вызывает `TryPop`:
    - Читает `head = NodeA` (значение 5, `Next = NodeB`).
    - Готовится выполнить CAS, чтобы обновить `head` на `NodeB`.
1. Поток B вмешивается:
    - Вызывает `TryPop`, удаляет `NodeA`, теперь `head = NodeB`.
    - Вызывает `TryPop`, удаляет `NodeB`, теперь `head = null`.
    - Вызывает `Push(5)`, создаёт новый узел `NodeA` (значение 5, `Next = null`) и устанавливает `head = NodeA`.
1. Поток A продолжает:
    - Выполняет CAS: сравнивает `head` (сейчас `NodeA`') с oldHead (`NodeA`). Значения совпадают (оба указывают на узлы с значением 5), поэтому CAS обновляет `head` на `NodeB`.

**Проблема:**
Поток A думает, что стек не изменился, так как head снова указывает на узел с значением 5.
На самом деле стек изменился: NodeA был удалён, а NodeA' — новый узел с другим Next (null вместо NodeB).
Это приводит к некорректному состоянию стека: head теперь указывает на NodeB, который уже удалён и может быть переиспользован или освобождён.

## Решения ABA-проблемы
{% cut "Использование версий или счётчиков (Tagged State)" %}
Хранить значение вместе с счётчиком изменений (версией). При каждом обновлении счётчик увеличивается, что делает каждое состояние уникальным.
{% endcut %}

{% cut "Double CAS (DCAS)" %}
Выполнять CAS для двух переменных одновременно (например, значение и указатель). В .NET стандартного DCAS нет, но можно эмулировать через структуры или использовать 64-битные long для хранения двух значений.
{% endcut %}

{% cut "Указатели с метками (Tagged Pointers)" %}
Включать счётчик изменений в младшие биты указателя (для 64-битных систем). Требует unsafe-кода в C#.
{% endcut %}

{% cut "Использование сборщика мусора" %}
В C# ABA-проблема с указателями (как в примере со стеком) менее критична, если объекты не переиспользуются, пока на них есть ссылки. Однако при ручном управлении памятью (например, через unsafe или пулы объектов) нужно быть осторожным.
{% endcut %}

{% cut "Hazard Pointers" %}
Каждый поток объявляет "hazard pointers" — указатели, которые он использует, чтобы предотвратить освобождение памяти другими потоками. Это сложный подход, редко используемый в C# из-за управляемой памяти.
{% endcut %}

{% cut "Использование готовых lock-free структур" %}
Вместо написания собственных CAS-алгоритмов использовать Concurrent коллекции (ConcurrentStack, ConcurrentQueue, ConcurrentDictionary), которые уже решают ABA-проблему под капотом.
{% endcut %}