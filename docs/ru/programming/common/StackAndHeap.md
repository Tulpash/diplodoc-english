# Стек и куча
Стек и куча — фундаментальные концепции, связанные с архитектурой процессоров (x86, ARM и т.д.) и операционных систем. Практически все языки используют их на низком уровне, но уровень абстракции и управления зависит от языка.

## Физическое отличие стека и кучи
Это разные области оперативной памяти (RAM), организованные для разных целей. Их физическое устройство и поведение определяются операционной системой и архитектурой процессора.

**Stack:**
- Непрерывный участок памяти фиксированного размера (обычно 1 МБ на поток в .NET и Go, но зависит от платформы).
- Управляется указателем стека (stack pointer, SP), который указывает на вершину стека.
- Работает по принципу LIFO (Last In, First Out): данные добавляются (push) и удаляются (pop) с вершины.
- Размер стека определяется при создании потока и ограничен (переполнение стека вызывает stack overflow).

**Heap:**
- Большой, неструктурированный участок памяти, управляемый операционной системой и/или рантаймом языка.
- Память выделяется динамически через системные вызовы (например, sbrk или mmap в Linux) или через аллокатор рантайма.
- Не имеет фиксированного размера, ограничена только доступной оперативной памятью.

|Аспект|Стек|Куча|
|---|---|---|
|Скорость|Очень быстрая аллокация. Аллокация - просто движение указателя|Медленная аллокация. аллокация - поиск свободного места в памяти.|
|Размер|Небольшой и фиксированный.|Ограничен только RAM.|
|Доступ|Линейный через вершину стека.|Слуйчайный доступ через ссылки (указатели).|
|Жизненный цикл|Данные видны только в пределах области видимости, после выхода из области стек "очищается" автоматически.|Данные существуют пока не будут явно очищены программистом или сборщиком мусора.|
|Проблемы|Слишком маленький для больших объектов.|Фрагментация. "Прибитые" данные|

## Есть ли стек и куча во всех языках программирования?
Практически во всех современных языках программирования есть концепции стека и кучи, но их реализация, использование и уровень явного контроля зависят от языка и его модели памяти.

{% note info "Языки с явным управлением памятью" %}

- **C**
- **C++**

{% endnote %}

{% note info "Языки с автоматическим управлением памятью" %}

- **C#**
- **Go**
- **Java**
- **Python**

{% endnote %}

{% note info "Уникальные способы управления памятью" %}

- **Haskell:** Сборка мусора и ленивые вычисления скрывают детали управления кучей.
- **Rust:** никальная модель владения (ownership) минимизирует ручное управление кучей, но стек и куча присутствуют.
- **Erlang:** Высокоуровневая модель акторов абстрагирует память, но физически стек и куча используются.

{% endnote %}