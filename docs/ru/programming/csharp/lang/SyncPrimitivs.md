# Примитивы синхронизации
Примитивы синхронизации в C# — это классы и конструкции из пространства имён System.Threading, предназначенные для координации потоков, предотвращения гонок данных и обеспечения thread-safety при доступе к общим ресурсам. Они делятся на категории в зависимости от механизма работы: те, что полагаются на блокировку от операционной системы (kernel-mode), те, что используют атомарные операции вроде Compare-and-Swap (CAS, user-mode), и гибридные или другие конструкции.
Я разделю их на запрошенные три категории на основе документации Microsoft и общих практик. Описание включает ключевые особенности, преимущества, недостатки и примеры использования. Обратите внимание, что некоторые примитивы (.NET 4.0+) имеют "Slim"-версии, которые оптимизированы для производительности.

## Примитивы, которые берут блокировку у ОС (kernel-mode синхронизация)
Эти примитивы используют системные вызовы операционной системы (например, Windows API) для создания kernel-объектов синхронизации. Они включают переключение контекста потоков (context switch), когда поток приостанавливается, если ресурс занят. Это делает их надёжными для длительных ожиданий, но дорогим по производительности (задержки до микросекунд из-за перехода в режим ядра). Подходят для сценариев с низкой конкуренцией или межпроцессной синхронизации.

{% cut "Mutex" %}

Обеспечивает взаимное исключение (mutual exclusion) для доступа к ресурсу. Может работать между процессами.
Особенности: Поток "захватывает" мьютекс (WaitOne), выполняет работу и освобождает (ReleaseMutex). Если занят, поток спит. Поддерживает именованные мьютексы для межпроцессного использования.
Преимущества: Надёжен для глобальной синхронизации; предотвращает "брошенные" мьютексы (abandoned mutex exception).
Недостатки: Высокая латентность (переключение в kernel); не подходит для высоконагруженных систем.
```cs
var mutex = new Mutex(); 
mutex.WaitOne(); 
/* критичная секция */ 
mutex.ReleaseMutex();
```
{% endcut %}

{% cut "Semaphore" %}

Счётчик, ограничивающий количество потоков, имеющих доступ к ресурсу (например, пул соединений).
Особенности: Инициализируется с максимальным счётом (`new Semaphore(initialCount, maxCount)`). `WaitOne` уменьшает счёт, `Release` увеличивает.
Преимущества: Гибкий для ограничения параллелизма; межпроцессный с именами.
Недостатки: Переключение контекста; риск семафорных "голоданий" (starvation).
```cs
var sem = new Semaphore(3, 3); s
em.WaitOne(); 
/* работа */ 
sem.Release();
```
{% endcut %}

{% cut "EventWaitHandle, AutoResetEvent, ManualResetEvent" %}

Сигналы для уведомления потоков о событиях (например, завершение задачи).
Особенности: AutoResetEvent сбрасывается автоматически после одного потока (Set для сигнала, WaitOne для ожидания). ManualResetEvent требует ручного сброса (Reset).
Преимущества: Полезны для producer-consumer сценариев; межпроцессные.
Недостатки: Дорогое ожидание; неэффективны для коротких операций.
```cs
var evt = new AutoResetEvent(false); 
evt.Set(); 
/* в одном потоке */ 
evt.WaitOne(); 
/* в другом */
```
{% endcut %}

{% cut "ReaderWriterLock" %}

Позволяет множественному чтению или эксклюзивному записи.
Особенности: AcquireReaderLock для чтения, AcquireWriterLock для записи.
Преимущества: Оптимизировано для сценариев с частым чтением.
Недостатки: Высокая латентность; в .NET 4+ заменён на ReaderWriterLockSlim.
{% endcut %}

## Примитивы, которые используют CAS (user-mode синхронизация)
Эти примитивы работают в пользовательском режиме (user-mode), используя атомарные инструкции процессора, такие как CAS (Compare-and-Swap). Они не вызывают системные вызовы ОС, а полагаются на спиннинг (активное ожидание в цикле) или атомарные операции. Это делает их быстрыми (наносекунды), но потенциально нагружающими CPU при высокой конкуренции. Идеальны для коротких операций с низким временем ожидания.

{% cut "Interlocked" %}

Класс для атомарных операций над переменными (например, инкремент, обмен).
Особенности: Методы вроде Increment, CompareExchange используют CAS для атомарности. Работает с примитивами (int, long) и объектами.
Преимущества: Lock-free; масштабируется на многоядерных системах; решает ABA-проблему в комбинации с версиями.
Недостатки: Ограничен простыми операциями; спиннинг при конфликтах.
```cs
Interlocked.Increment(ref counter); 
Interlocked.CompareExchange(ref value, newValue, expectedValue);
```
{% endcut %}

{% cut "SpinLock" %}

Лёгкая блокировка с активным ожиданием (спиннингом).
Особенности: Enter использует CAS для захвата; если занят, крутится в цикле. Exit освобождает.
Преимущества: Очень быстро для коротких критических секций (микросекунды); не вызывает переключения контекста.
Недостатки: Нагружает CPU при долгом ожидании; не подходит для длительных операций.
```cs
var spinLock = new SpinLock(); 
bool taken = false; 
spinLock.Enter(ref taken); 
/* секция */ 
spinLock.Exit();
```
{% endcut %}

{% cut "SpinWait" %}

Помощник для спиннинга в lock-free алгоритмах.
Особенности: Метод SpinOnce выполняет паузу или спин, адаптируясь к системе (например, yield на однопроцессорных машинах).
Преимущества: Оптимизирует спиннинг, снижая нагрузку на CPU.
Недостатки: Не самостоятельный примитив, а вспомогательный.
```cs
while (!condition) 
    SpinWait.SpinUntil(() => condition);
```
{% endcut %}

## Все остальные (гибридные и другие примитивы)
Эти примитивы комбинируют user-mode (CAS/спиннинг) и kernel-mode (ОС-блокировку) для баланса производительности и надёжности, или используют другие механизмы. Они начинают с лёгких операций, но переходят в kernel при длительном ожидании. Подходят для большинства сценариев, где нужна гибкость.

{% cut "Monitor" %}

Основной механизм для взаимного исключения, используемый через ключевое слово lock.
Особенности: начинается с CAS/спиннинга, переходит в kernel-ожидание. Методы Enter, Exit, Pulse для уведомлений.
Преимущества: Простота использования; поддерживает условные ожидания (Wait, Pulse).
Недостатки: Риск взаимоблокировок; overhead при высокой конкуренции.
```cs
lock (obj) 
{ 
    /* секция */ 
}
```
{% endcut %}

{% cut "ReaderWriterLockSlim" %}

Оптимизированная версия для множественного чтения/эксклюзивной записи.
Особенности: использует спиннинг, затем kernel. Поддерживает рекурсию и апгрейд лока (с чтения на запись).
Преимущества: Лучше старого ReaderWriterLock; производительнее для read-heavy сценариев.
Недостатки: Сложнее в использовании; возможны голодания.
```cs
var rwls = new ReaderWriterLockSlim();
rwls.EnterReadLock();
/* чтение */
rwls.ExitReadLock();
```
{% endcut %}

{% cut "ManualResetEventSlim, SemaphoreSlim" %}

Лёгкие версии kernel-примитивов (events и семафоры).
Особенности: спиннинг на короткое время, затем kernel-ожидание. Не межпроцессные.
Преимущества: Быстрее полных версий; подходят для внутрипроцессной синхронизации.
Недостатки: Нет поддержки имён; ограничены одним процессом.
```cs
var mres = new ManualResetEventSlim(); 
mres.Set(); 
mres.Wait();
```
{% endcut %}

{% cut "Barrier" %}

Синхронизирует фазы выполнения нескольких потоков (например, в параллельных алгоритмах).
Особенности: Потоки ждут на барьере (SignalAndWait), пока все не соберутся. Гибридный с CAS.
Преимущества: Полезен для параллельных вычислений (например, в Parallel.For).
Недостатки: Не для произвольной синхронизации.
```cs
var barrier = new Barrier(participantCount: 3); 
barrier.SignalAndWait();
```
{% endcut %}

{% cut "CountdownEvent" %}

Счётчик сигналов, ждущий, пока все не завершатся.
Особенности: Signal уменьшает счёт, Wait ждёт нуля. Гибридный.
Преимущества: Прост для координации задач (например, с Task Parallel Library).
Недостатки: Не сбрасывается автоматически.
```cs
var cde = new CountdownEvent(5); 
cde.Signal(); 
cde.Wait();
```
{% endcut %}

{% cut "Volatile" %}

Ключевое слово или методы `Volatile.Read/Write` для обеспечения видимости изменений переменных между потоками.
Особенности: Вставляет memory barriers, предотвращая оптимизации компилятора/процессора (reordering).
Преимущества: Лёгкий; не использует CAS напрямую, но обеспечивает coherent чтение/запись.
Недостатки: Не атомарен для операций; не заменяет полноценную синхронизацию.
```cs
volatile int flag;
/* или */
Volatile.Write(ref flag, 1);
```
{% endcut %}