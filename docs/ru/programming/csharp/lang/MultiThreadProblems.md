# Типичные проблемы в асинхронном и многопоточном коде

## Deadlock
Это ситуация, когда два или более потока блокируют друг друга, ожидая освобождения ресурсов (например, блокировок), которые удерживаются другими потоками. В результате все потоки "застревают" и не могут продолжить выполнение.
**Причины:**
- Несколько потоков запрашивают несколько блокировок в разном порядке.
- Отсутствие строгого протокола захвата блокировок.
- Циклические зависимости между потоками и ресурсами (например, поток A ждёт ресурс B, а поток B ждёт ресурс A).
**Решение:**
- Избегать вложенных блокировок (lock)
- Использовать async/await для асинхронного доступа к ресурсам
- Применять таймауты (Monitor.TryEnter)

## Race Conditions
Это ситуация, когда результат выполнения программы зависит от порядка выполнения операций в разных потоках, потому что они одновременно изменяют общий ресурс без должной синхронизации. Это приводит к непредсказуемым или некорректным результатам.
**Причины**
- Два или более потока одновременно читают и изменяют общий ресурс (например, переменную, массив, объект).
- Отсутствие синхронизации (например, блокировок, атомарных операций или других примитивов).
- Операции, которые кажутся атомарными, но на самом деле состоят из нескольких шагов (например, counter++ включает чтение, инкремент и запись).
**Решение:**
- Использовать блокировки (lock, Monitor) или lock-free коллекции
- Применять атомарные операции (Interlocked)

## Thread Starvation
Это ситуация, когда поток не получает доступа к ресурсу или процессорному времени, необходимому для выполнения, из-за конкуренции с другими потоками или неправильного управления синхронизацией.
**Причины:**
- Высокая конкуренция за ресурсы (например, блокировки, семафоры), где некоторые потоки редко получают доступ.
- Планировщик потоков ОС или CLR отдаёт предпочтение потокам с более высоким приоритетом.
- Неправильная настройка примитивов синхронизации (например, семафоры с низким счётом или несправедливые блокировки).
- Слишком много потоков в пуле, что перегружает планировщик.
**Решение:**
- Использовать SemaphoreSlim или ReaderWriterLockSlim, которые обеспечивают FIFO (First-In-First-Out) порядок доступа.
- Не устанавливать разный приоритет потоков, если это не критично (Thread.Priority).
- Уменьшить количество потоков, использующих общий ресурс.
- Использовать пул потоков (Task.Run) для управления нагрузкой.
- Использовать lock-free
- Применять Interlocked или Concurrent коллекции для минимизации ожидания.
- Использовать таймауты в Monitor.TryEnter или SemaphoreSlim.Wait для предотвращения бесконечного ожидания.

## async/await
*Блокировка контекста:* Использование .Result или .Wait() в асинхронном коде может привести к взаимоблокировкам, особенно в UI-приложениях.
*Неправильная настройка контекста:* Неправильное использование ConfigureAwait(false) может вызвать проблемы в UI или ASP.NET контекстах.
**Решение:**
- Избегать .Result и .Wait(), использовать await
- Использовать ConfigureAwait(false) для библиотечного кода, если контекст не важен

## Утечки памяти
Долгоживущие ссылки на объекты (например, в обработчиках событий) или неправильное управление асинхронными задачами.
**Решение:**
- Использовать WeakReference для слабых ссылок
- Отменять задачи с помощью CancellationToken

## Избыточное выделение потоков
Создание слишком большого числа потоков приводит к перегрузке пула потоков
**Решение:**
- Использовать пул потоков или Task для асинхронных операций
- Ограничивать параллелизм с помощью SemaphoreSlim

## Непредсказуемое выделение асинхронных операций
Неправильная обработка исключений или незавершенных задач.
**Решение:**
- Всегда обрабатывать исключения в try/catch при использовании await
- Использовать Task.WhenAll для управления несколькими задачами