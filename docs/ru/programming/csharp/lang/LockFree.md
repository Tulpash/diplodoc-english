# Lock-free
Это подход к многопоточной синхронизации, который избегает традиционных блокировок (например, lock или Monitor), чтобы минимизировать риски взаимоблокировок (deadlocks), снизить задержки переключения контекста и повысить производительность в высококонкурентных сценариях. Compare-and-Swap (CAS) — это один из основных механизмов lock-free синхронизации, реализованный в C# через методы класса System.Threading.Interlocked, такие как CompareExchange. Однако есть и другие способы и техники для достижения lock-free поведения, которые либо дополняют CAS, либо используют альтернативные подходы.

## CAS (compare and swap)
Это атомарная операция, используемая в многопоточной программировании для синхронизации доступа к общим ресурсам без использования блокировок (lock-free подход). CAS позволяет атомарно (т.е. как единую неделимую операцию) сравнить значение в памяти с ожидаемым значением и, если они совпадают, заменить его на новое значение. Если сравнение не удаётся (значение в памяти изменилось, например, из-за другого потока), операция возвращает исходное значение, и обычно попытка повторяется в цикле.

**Преимущества:**
- Избегает блокировок, что снижает риск взаимоблокировок (deadlocks) и повышает производительность в высококонкурентных сценариях.
- Масштабируемость: Хорошо работает на многоядерных процессорах.

**Недостатки:**
- ABA-проблема: Если значение изменяется на A → B → A, CAS может подумать, что ничего не изменилось, хотя на самом деле изменилось. Решение: Использовать версии или теги (например, комбинировать значение с счётчиком).
- Может приводить к "спиннингу" (пустым циклам), если конфликты часты, что нагружает CPU.
- Сложность реализации: Требует осторожности в проектировании.

## Атомарные операции (расширение CAS)
Атомарные операции, помимо CAS, предоставляют другие способы манипуляции данными в lock-free манере. Они также используют аппаратные инструкции процессора (например, xadd, xchg), но выполняют другие действия, чем сравнение и обмен. В C# эти операции доступны через класс `Interlocked`.

{% cut "Атомарный инкремент/декремент (`Interlocked.Increment/Decrement`)" %}
Атомарно увеличивает или уменьшает значение переменной на 1.
```cs
int counter = 0;
Interlocked.Increment(ref counter); // Атомарно увеличивает counter до 1
Console.WriteLine(counter); // 1
```
{% endcut %}

{% cut "Атомарное добавление (`Interlocked.Add`)" %}
Атомарно добавляет указанное значение к переменной.
```cs
long total = 0;
Interlocked.Add(ref total, 500); // Атомарно добавляет 500
Console.WriteLine(total); // 500
```
{% endcut %}

{% cut "Атомарный обмен (`Interlocked.Exchange`)" %}
Атомарно заменяет значение переменной на новое и возвращает старое.
```cs
int value = 10;
int oldValue = Interlocked.Exchange(ref value, 20); // value = 20, oldValue = 10
Console.WriteLine($"Старое: {oldValue}, Новое: {value}");
```
{% endcut %}

{% cut "Атомарное чтение/запись (`Volatile.Read/Write`)" %}
Гарантирует правильный порядок чтения/записи переменных с использованием барьеров памяти (memory barriers).
```cs
int flag = 0;
Interlocked.Exchange(ref flag, 1); // Запись с барьером
int read = Volatile.Read(ref flag); // Чтение с барьером
```
{% endcut %}

## Lock-free структуры данных
Вместо написания собственных lock-free алгоритмов с использованием Interlocked, можно использовать готовые thread-safe коллекции, которые реализуют lock-free или частично lock-free поведение. В C# они находятся в пространстве имён System.Collections.Concurrent.
- `ConcurrentDictionary<TKey, TValue>`
- `ConcurrentQueue<T>`
- `ConcurrentStack<T>`
- `ConcurrentBag<T>`

## Сегментация данных (Data Partitioning)
Это подход, при котором общий ресурс делится на независимые части, чтобы каждый поток работал с собственной "порцией" данных, избегая конкуренции. Это не примитив синхронизации, а архитектурный способ достижения lock-free поведения.

{% cut "Локальные данные потока (Thread-Local Storage)" %}
Хранение данных, уникальных для каждого потока, с помощью `ThreadLocal<T>` или `[ThreadStatic]`.
```cs
ThreadLocal<int> localCounter = new ThreadLocal<int>(() => 0);
Parallel.For(0, 1000, i =>
{
    localCounter.Value++; // Каждый поток инкрементирует свою копию
});
int total = localCounter.Values.Sum(); // Суммируем результаты
Console.WriteLine(total);
```
{% endcut %}

{% cut "Шардирование (Sharding)" %}
Разделение данных на независимые сегменты (шарды), каждый из которых обрабатывается отдельным потоком.
```cs
int[] data = new int[1000];
Parallel.ForEach(Partitioner.Create(0, data.Length), range =>
{
    for (int i = range.Item1; i < range.Item2; i++)
        data[i]++; // Каждый поток работает с частью массива
});
```
{% endcut %}

## Иммутабельные структуры данных
Использование неизменяемых (immutable) данных позволяет избежать синхронизации, так как потоки не изменяют общие данные.

{% cut "Immutable Collections" %}
Коллекции, которые не изменяются после создания, доступны в `System.Collections.Immutable`. Вместо изменения создаётся новая версия коллекции.
```cs
using System.Collections.Immutable;

var list = ImmutableList<int>.Empty;
var newList = list.Add(1); // Создаёт новую копию
Console.WriteLine(newList[0]); // 1, исходный list не изменился
```
{% endcut %}

{% cut "Record Types (C# 9+)" %}
Неизменяемые записи (records) для создания неизменяемых объектов. Изменения создают новые экземпляры (через `with`).
```cs
record Point(int X, int Y);
var p1 = new Point(1, 2);
var p2 = p1 with { X = 3 }; // Новый экземпляр
Console.WriteLine(p1.X); // 1
```
{% endcut %}

## Software Transactional Memory (STM)
Хотя в .NET нет встроенной реализации STM, это концепция lock-free синхронизации, где изменения применяются транзакционно. STM обрабатывает операции как транзакции: изменения накапливаются, затем атомарно применяются или откатываются.

## Message Passing (Передача сообщений)
Вместо совместного использования памяти потоки обмениваются сообщениями, что исключает необходимость синхронизации.

{% cut "Channels (System.Threading.Channels, .NET Core 2.1+)" %}
Асинхронная очередь для передачи сообщений между потоками.
```cs
using System.Threading.Channels;
using System.Threading.Tasks;

var channel = Channel.CreateUnbounded<int>();
Task.Run(async () => await channel.Writer.WriteAsync(42));
var value = await channel.Reader.ReadAsync(); // 42
```
{% endcut %}