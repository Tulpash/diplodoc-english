# Основные конкурентные структуры и операции над ними

## ConcurrentDictionary<TK, TV>
**Идейно:** Потокобезопасный словарь (ассоциативный массив), где ключи уникальны, а доступ по ключу и модификации выполняются безопасно в многопоточных сценариях. Подходит для кэшей, хранения пар ключ-значение с конкурентным доступом.
**Внутри:** Использует хеш-таблицу, как Dictionary<TKey, TValue>, но с сегментированной блокировкой (lock striping). Таблица делится на "бакеты", каждый из которых защищён отдельным локальным замком (lock). Это позволяет разным потокам работать с разными бакетами одновременно, минимизируя конкуренцию. При росте таблицы (ресайзинг) используется глобальная блокировка, но это происходит редко. Ключи должны поддерживать GetHashCode и Equals (или IEqualityComparer).
**Сложность операций:**
- Добавление: O(1)
- Получение/Обновление: O(1)
- Удаление: O(1)
- Проверка: O(1)

## ConcurrentQueue<T>
**Идейно:** Потокобезопасная очередь FIFO (First-In-First-Out). Элементы добавляются в конец и извлекаются с начала. Подходит для сценариев "производитель-потребитель" (producer-consumer), где потоки добавляют и обрабатывают задачи.
**Внутри:** Реализована как связный список с указателями на голову и хвост, защищёнными с помощью атомарных операций (например, Interlocked.CompareExchange). Это позволяет избежать полных блокировок, обеспечивая высокую производительность в конкурентных сценариях.
**Сложность операций:**
- Добавление: O(1)
- Извлечение: O(1)
- Просмотр: O(1)

## ConcurrentStack<T>
**Идейно:** Потокобезопасный стек LIFO (Last-In-First-Out). Элементы добавляются и извлекаются с вершины. Подходит для сценариев, где важен порядок "последний вошёл — первый вышел", например, для отмены операций (undo).
**Внутри:** Как и ConcurrentQueue, использует связный список с атомарными операциями для управления вершиной стека. Атомарные операции (например, Interlocked) обеспечивают безопасность без явных блокировок.
**Сложность операций:**
Добавление: O(1)
Добавление диапазона: O(k)
Извлечение: O(1)
Извлечение диапазона: O(k)
Просмотр: O(1)

## ConcurrentBag<T>
**Идейно:** Потокобезопасная "сумка" (bag) для хранения неупорядоченных элементов. Подходит для сценариев, где порядок не важен, а потоки добавляют и извлекают элементы произвольно (например, пул объектов).
**Внутри:** Каждый поток имеет свою локальную "сумку" (внутренний список), что минимизирует конкуренцию при добавлении. При извлечении поток сначала пытается взять элемент из своей локальной сумки, а если она пуста — "крадёт" (steals) элементы из сумок других потоков. Это реализовано с помощью атомарных операций, но "воровство" может быть дороже (O(n) в худшем случае).
**Сложность операций:**
Добавление: O(1)
Извлечение: O(1)
Извлечение в чужой сумке: O(n)
Просмотр: O(1)
Просмотр в чужой сумке: O(n)

## BlockingCollection<T>
**Идейно:** Потокобезопасная коллекция, которая блокирует потоки при попытке извлечь элемент из пустой коллекции или добавить в полную (если задан лимит). Часто используется в сценариях "производитель-потребитель" с ограниченной ёмкостью. Может оборачивать другие конкурентные коллекции (по умолчанию ConcurrentQueue<T>).
**Внутри:** Оборачивает базовую коллекцию (например, ConcurrentQueue или ConcurrentBag) и добавляет блокирующую семантику с использованием мониторов и событий (Monitor.Wait, Monitor.Pulse). Поддерживает ограничение размера (bounded capacity).
**Сложность операций:**
Добавление: O(1) (для базовой коллекции, блокирует, если полна)
Извлечение: O(1) (блокирует, если пуста)