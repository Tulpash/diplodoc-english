# Кофнигурация режима работы GC
GC поддерживает два основных режима работы (GC mods), которрые определяют то как он взаиможействует с приложением:

## Workstation GC
Оптимизирован для клиентских прилрожений с низкой задержкой. Этот режим предполагает, что приложение работает на одном устройстве и приоритет отдается отзывчивости пользовательского интерфейса.

### Особенности:
- Работает в одном процессе с приложением
- Используте меньше памяти но не эффективен для высоко нагруженных приложений

### Подрежимы
- **Concurrent:** GC работает параллельно с приложением (по умолчанию в .NET Framework)
- **Non-concurrent:** Работает в одном потоке с приложением, что может вызвать паузы в UI, но быстрее освобождает память

{% note info "Когда использовать" %}

Для декстопных приложений в которых важна низкая задержка для UI.

{% endnote %}

## Server GC
Оптимизирован для серверных приложений с высокой нагрузкой. Использует все процессоры, так что лучше работает на многопроцессорных системах.

### Особенности
- Создает отдельную кучу и поток GC для каждого логического процессора ОС
- Использует больше памяти но обечпесивает лучшую производительность при больших нагрузках

{% note warning %}

В .NET Core и .NET 5 использует фоновую уборку (Backgroung GC), котолрая минимизирует паузы путем:
- Уборка поколений 0 и 1 происходит параллельно с приложением
- Уборка поколения 2 происходит после остановки основног опотока (как обычно)

На однопроцессорных системах ServerGC будет работать как WorkstationGC

{% endnote %}

{% note info "Когда использовать" %}

Для серверных приложений, таких как API на ASP.NET Core, где важна высокая пропускная способность и масштабируемость.

{% endnote %}

## Как переключать режимы
Для этого есть `System.Runtime.GCSettings.IsServerGC`, `true` для включения **ServerGC**, `false` для включения **WorkstationGC**.
Также режим моджно настроить через конфиг приложения:
```json
{
    "runtimeOptions": {
        "configProperties": {
            "System.GC.Server": false, // Включение Workstation GC
            "System.GC.Concurrent": true // Включение concurrent GC
        }
    }
}
```

## GCHeapCount
Ограничивает число куч в Server GC (по умолчанию равно числу логических ядер).
- Environment: `DOTNET_GCHeapCount=4`
- .NET Framework: `<GCMaximumHeapCount value="4"/>`
**Пример использования:** Ограничить кучи на сервере с 32 ядрами до 8 для экономии RAM.

## GCNoAffinitize
Отключает heap affinity в Server GC (привязку потоков к кучам/ядрам).
- Environment: `DOTNET_GCNoAffinitize=1` (1 = отключить affinity)
**Пример использования:** Тестирование или приложения с низкой нагрузкой, где affinity не даёт прироста.

## GCAffinitizeMask
Битовая маска для привязки куч к конкретным CPU (для NUMA-систем).
- Environment: `DOTNET_GCAffinitizeMask=0x0F` (например, привязка к ядрам 0-3)
**Пример использования:** Серверы с NUMA (многосокетные), где доступ к "чужой" памяти дорог.

## GCLatencyMode
Управляет режимом latency GC (как GC балансирует паузы и производительность).
- Код: `GCSettings.LatencyMode = GCLatencyMode.LowLatency`
- Environment: Не поддерживается напрямую, но можно комбинировать с GCConcurrent
**Значения:**
- Batch (0): Максимальная пропускная способность, длинные паузы (Server GC по умолчанию)
- Interactive (1): Минимизация пауз, для UI (Workstation по умолчанию)
- LowLatency (2): Минимизирует GC-паузы для короткоживущих операций (например, трейдинг)
- SustainedLowLatency (3): Баланс, минимизирует паузы, но сохраняет пропускную способность (.NET Core/5+)
- NoGCRegion (4): Временное отключение GC в критических секциях (через GC.TryStartNoGCRegion)
**Пример использования:** LowLatency для финансовых приложений, где паузы критичны.

## GCHeapHardLimit
Ограничивает общий размер кучи (в байтах) для всех поколений.
- Environment: `DOTNET_GCHeapHardLimit=0x40000000` (например, 1 ГБ)
**Пример использования:** Docker, где RAM строго ограничен.

## GCLOHTreshold
Задаёт порог для Large Object Heap (по умолчанию 85 КБ).
- Environment: `DOTNET_GCLOHThreshold=0x100000` (например, 1 МБ)
**Пример использования:** Приложения с большими массивами, где стандартный порог не оптимален.

## GCConserveMemory
Контролирует, как агрессивно GC освобождает память (0-9, где 9 = максимально экономить).
- Environment: `DOTNET_GCConserveMemory=9`
**Пример использования:** Ограниченные среды, где важна экономия CPU.